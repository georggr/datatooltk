#!/usr/bin/perl -w
# File   : createdocs
# Author : Nicola L. C. Talbot
# Date   : 2013-06-06

use strict;
use XML::XPath;

if ($#ARGV > 1 || $#ARGV < 0)
{
   die "Syntax: $0 <lang> [<region>]\n";
}

my $dictdir = '../../resources/dictionaries';
my $mainclass = '../../src/DatatoolTk.java';
my $base = 'datatooltk';

# mapping between xml encoding names and inputenc options

my %inputenc = 
 (
    'utf-8' => 'utf8',
    'ios-8859-1' => 'latin1'
 );

# default
my $encoding = 'utf-8';

# mapping between locales and babel options

my %babel =
 (
    'en'    => 'english',
    'en-GB' => 'british',
    'en-US' => 'american',
    'fr'    => 'frenchb'
 );

# mapping between HTML entities and LaTeX commands
my %entities =
 (
    'nbsp'   => '\\nbsp ',
    'amp'    => '\\ampersand',
    'quot'   => '\\doublequote ',
    'lt'     => '\\lessthan ',
    'gt'     => '\\greaterthan ',
    'iexcl'  => '\\textexclamdown ',
    'pound'  => '\\pounds ',
    'sect'   => '\\S ',
    'copy'   => '\\copyright ',
    'laquot' => '\\textquotedblleft ',
    'reg'    => '\\textregistered ',
    'para'   => '\\P ',
    'iquest' => '\\textquestiondown ',
    'Agrave' => '\\`A',
    'Aacute' => "\\'A",
    'Acirc'  => '\\^A',
    'Atilde' => '\\~A',
    'Auml'   => '\\"A',
    'Aring'  => '\\r{A}',
    'AElig'  => '\\AE ',
    'Ccedil' => '\\c{c}',
    'Egrave' => '\\`E',
    'Eacute' => "\\'E",
    'Ecirc'  => '\\^E',
    'Euml'   => '\\"E',
    'Igrave' => '\\`I',
    'Iacute' => "\\'I",
    'Icirc'  => '\\^I',
    'Iuml'   => '\\"I',
    'Ntilde' => '\\~N',
    'Ograve' => '\\`O',
    'Oacute' => "\\'O",
    'Ocirc'  => '\\^O',
    'Ouml'   => '\\"O',
    'times'  => '\\times ',
    'Oslash' => '\\O ',
    'Ugrave' => '\\`U',
    'Uacute' => "\\'U",
    'Ucirc'  => '\\^U',
    'Uuml'   => '\\"U',
    'Yacute' => "\\'Y",
    'szlig'  => '\\ss ',
    'agrave' => '\\`a',
    'aacute' => "\\'a",
    'acirc'  => '\\^a',
    'atilde' => '\\~a',
    'auml'   => '\\"a',
    'aring'  => '\\r{a}',
    'aelig'  => '\\ae ',
    'ccedil' => '\\c{c}',
    'egrave' => '\\`e',
    'eacute' => "\\'e",
    'ecirc'  => '\\^e',
    'euml'   => '\\"e',
    'igrave' => '\\`i',
    'iacute' => "\\'i",
    'icirc'  => '\\^i',
    'iuml'   => '\\"i',
    'ntilde' => '\\~n',
    'ograve' => '\\`o',
    'oacute' => "\\'o",
    'ocirc'  => '\\^o',
    'ouml'   => '\\"o',
    'divide' => '\\divide ',
    'oslash' => '\\o ',
    'ugrave' => '\\`u',
    'uacute' => "\\'u",
    'ucirc'  => '\\^u',
    'uuml'   => '\\"u',
    'yacute' => "\\'y",
    'ygrave' => '\\`y',
    'yuml'   => '\\"y',
 );

my %specialchars =
 (
    '&'  => '\\ampersand ',
    '~'  => '\\textasciitilde ',
    '^'  => '\\textasciicircum ',
    "\\" => '\\textbackslash ',
    '{'  => '\\leftbrace ',
    '}'  => '\\rightbrace ',
    '_'  => '\\underscore ',
    '%'  => '\\textpercent ',
    '#'  => '\\texthash ',
    '$'  => '\\textdollar '
 );

my %textags =
 (
    'br'   => "\\\\",
    'hr'   => "\\hrulefill "
 );

my $lang = $ARGV[0];

my $locale = $lang;

if ($#ARGV == 1)
{
  $locale .= "-".$ARGV[1];
}

open FD, "$mainclass" or die "Can't open '$mainclass' $!\n";
binmode(FD, ":utf8");

my %dict = ();

while (<FD>)
{
   if (/public +static +final +String +appName *= *"([^"]+)"/)
   {
      $dict{appname} = $1;
   }
   elsif (/public +static +final +String +appVersion *= *"([^"]+)"/)
   {
      $dict{appversion} = $1;
   }
   elsif (/public +static +final +String +appDate *= *"([^"]+)"/)
   {
      $dict{appdate} = $1;
   }
}

close FD;

my $propfile = "$dictdir/$base-$locale.prop";

if (not (-e $propfile) and ($lang ne $locale))
{
   $propfile = "$dictdir/$base-$lang.prop";

   unless (-e $propfile)
   {
      die "Can't find either '$dictdir/$base-$locale.prop' or '$propfile'\n";
   }
}

unless (-e $propfile)
{
   die "Can't find '$propfile'\n";
}

open FD, "$propfile" or die "Can't open '$propfile' $!\n";
binmode(FD, ":utf8");

my $linenum = 0;

while (<FD>)
{
   $linenum++;

   next if (/^ *#/ or /^ *$/);

   if (/^([^=]+)=(.*)$/)
   {
      $dict{$1} = $2;
   }
   else
   {
      warn "$propfile: Can't parse line $linenum\n";
   }
}

close FD;

my $xmlfile = "$base-$locale.xml";

if (not (-e $xmlfile) and ($lang ne $locale))
{
   $xmlfile = "$base-$lang.xml";

   unless (-e $xmlfile)
   {
      die "Can't find either '$base-$locale.xml' or '$xmlfile'\n";
   }
}

unless (-e $xmlfile)
{
   die "Can't find '$xmlfile'\n";
}

my $texfile = "$base-$locale.tex";
my $helpsetdir = "$dictdir/helpset-$locale";

unless (-e $helpsetdir)
{
   mkdir $helpsetdir or die "Can't mkdir '$helpsetdir' $!\n";
}

unless (-d $helpsetdir)
{
   die "'$helpsetdir' is not a directory\n";
}

my $xp = XML::XPath->new(filename=>$xmlfile);

# TODO work out how to get the xml encoding from $xp

my $inputenc = $inputenc{$encoding} ? $inputenc{$encoding} : $encoding;

my $nodeset = $xp->find('//newacro');

my %acros = ();

foreach my $element ($nodeset->get_nodelist)
{
   my $label = $element->string_value;

   $acros{$label}->{Long} = $element->getAttribute('long');
   $acros{$label}->{Short} = $element->getAttribute('short');

   unless ($acros{$label}->{Short})
   {
      warn "Acronym '$label' missing 'short' attribute\n";
   }

   unless ($acros{$label}->{Long})
   {
      warn "Acronym '$label' missing 'long' attribute\n";
   }
}

my @tags = ();

my %nodes = ();

$nodeset = $xp->find('//node');

foreach my $element ($nodeset->get_nodelist)
{
   my $tag = $element->getAttribute('tag');
   my $type = $element->getAttribute('type');
   my $title = $element->getAttribute('title');

   push @tags, $tag;

   $nodes{$tag}->{Type}  = $type;
   $nodes{$tag}->{Title} = $title;
   $nodes{$tag}->{Element} = $element;
}

my %counters = ();

my @floattags = ();

my %floats = ();

$nodeset = $xp->find('//float');

foreach my $element ($nodeset->get_nodelist)
{
   my $tag     = $element->getAttribute('tag');
   my $type    = $element->getAttribute('type');
   my $caption = $element->getAttribute('caption');

   unless ($tag)
   {
      warn "Missing tag in float\n";
   }

   unless ($type)
   {
      warn "Missing type in float\n";
   }

   unless ($caption)
   {
      warn "Missing caption in float\n";
   }

   push @floattags, $tag;

   $floats{$tag}->{Type}    = $type;
   $floats{$tag}->{Caption} = $caption;
   $floats{$tag}->{Element} = $element;

   if ($counters{$type})
   {
      $counters{$type}++;
   }
   else
   {
      $counters{$type} = 1;
   }

   $floats{$tag}->{Number} = $counters{$type};

   $floats{$tag}->{Parent} = $element->getParentNode->getAttribute("tag");
}

$nodeset = $xp->find('//fontenc');

my $fontenc = 'T1';

if (my @nodelist = $nodeset->get_nodelist)
{
   if ($#nodelist != 0)
   {
      warn "Only one <fontenc> permitted\n";
   }

   $fontenc = $nodelist[0]->string_value;
}

my $title;

$nodeset = $xp->find('//title');

if (my @nodelist = $nodeset->get_nodelist)
{
   if ($#nodelist != 0)
   {
      warn "Only one <title> permitted\n";
   }

   $title = $nodelist[0];
}

$nodeset = $xp->find('//author');

my @authors =  $nodeset->get_nodelist;

my @texauthors = ();

foreach my $element (@authors)
{
   push @texauthors, &texfmt($element->toString);
}

my $date;

$nodeset = $xp->find('//date');

if (my @nodelist = $nodeset->get_nodelist)
{
   if ($#nodelist != 0)
   {
      warn "Only one <date> permitted\n";
   }

   $date = $nodelist[0];
}

open TEXFD, ">$texfile" or die "Can't open '$texfile' $!\n";
binmode(TEXFD, ":$inputenc");

my $paper = 'a4paper';

if ($locale=~/en-US/)
{
   $paper = 'letterpaper';
}

print TEXFD <<_END_PREAMBLE;
% arara: pdflatex
% arara: makeglossaries
% arara: makeindex
% arara: pdflatex
% arara: pdflatex
\\documentclass[$paper]{$base}

\\usepackage[$inputenc]{inputenc}
\\usepackage[$fontenc]{fontenc}
\\usepackage{graphicx}
\\usepackage{makeidx}
\\usepackage[colorlinks]{hyperref}
\\usepackage[acronym]{glossaries}

\\makeindex
\\makeglossaries

_END_PREAMBLE

foreach my $label (keys %acros)
{
   print TEXFD "\\newacronym{$label}{", 
    $acros{$label}->{Short}, "}{",
    $acros{$label}->{Long}, "}\n";
}

print TEXFD "\\title{", &texfmt($title->toString), "}\n" if ($title);
print TEXFD "\\author{", join('\\and ', @texauthors), "}\n";
print TEXFD "\\date{", &texfmt($date->toString), "}\n";

print TEXFD "\\begin{document}\n", "\\maketitle\n";

foreach my $tag (@tags)
{
   my $element = $nodes{$tag}->{Element};

   if ($nodes{$tag}->{Type}=~/(section|chapter)/)
   {
      print TEXFD "\\", $nodes{$tag}->{Type},
        "{", &texfmt($nodes{$tag}->{Title}), "}\n";
      print TEXFD "\\label{$tag}\n";
   }

   print TEXFD &texfmt($nodes{$tag}->{Element}->toString), "\n";
}

print TEXFD "\\end{document}\n";
close TEXFD;

sub texfmt{
   my $string = shift;

   $string=~s/<dict>(.+?)<\/dict>/$dict{$1}/g;

   $string=~s/<acr>(.+?)<\/acr>/\\gls\{$1\}/g;

   $string=~s/<opt>(.+?)<\/opt>/\\opt\{$1\}/g;

   $string=~s/<ref>(.+?)<\/ref>/\\autoref\{$1\}/g;

   if ($string=~/<cs>printacronyms<\/cs>/)
   {
      if ($nodes{acronyms}->{Title})
      {
         $string=~s/<cs>printacronyms<\/cs>/\\printglossary[type=acronym,title=\{$nodes{acronyms}->{Title}\}]/;
      }
      else
      {
         $string=~s/<cs>printacronyms<\/cs>/\\printglossary[type=acronym]/;
      }
   }

   $string=~s/<menu>(.+?)<\/menu>/&texmenu($1)/eg;

   $string=~s/<url>(.+?)<\/url>/\\url\{$1\}/g;

   $string=~s/<footnote>(.+?)<\/footnote>/\\footnote\{$1\}/sg;

   $string=~s/<cs>(.+?)<\/cs>/\\$1/g;

   $string=~s/<xcs>(.+?)<\/xcs>/\\$1\{\}/g;

   $string=~s/<tt>(.+?)<\/tt>/\\texttt\{$1\}/sg;

   $string=~s/<b>(.+?)<\/b>/\\textbf\{$1\}/sg;

   $string=~s/<em>(.+?)<\/em>/\\emph\{$1\}/sg;

   $string=~s/<i>(.+?)<\/i>/\\emph\{$1\}/sg;

   $string=~s/<\/?p>/\n\n/g;

   $string=~s/(<image.*>.+?<\/image>)/&teximage($1)/eg;

   $string=~s/(<float[^>]*>.+?<\/float>)/&texfloat($1)/seg;

   $string=~s/\&([^;]);/&texentity($1)/eg;

   $string=~s/<([a-z]+) *\/>/&textag($1)/eg;

   # remove any remaining tags

   $string=~s/<\/?[^>]+>//g;

   $string
}

sub textag{
   my $tag = shift;

   ($textags{$tag} ? $textags{$tag} : '')
}

sub teximage{
   my $xml = shift;

   $xml=~/<image\s*(.*)\s*>(.+)<\/image>/;

   my $opts = $1;
   my $imgFile=$2;

   unless (-e $imgFile)
   {
      warn "Can't find '$imgFile'\n";
      return "";
   }

   if ($opts)
   {
      $opts=~s/alt="[^"]+"//;

      $opts=~tr/ +/,/;
      $opts=~tr/"//;
   }

   "\\includegraphics[$opts]{$imgFile}";
}

sub texfloat{
   my $xml = shift;

   my $contents = '';
   my $tag;

   if ($xml=~/<float.*? tag="([^"]+)".*?>(.*)<\/float>/s)
   {
      $tag = $1;
      $contents = $2;

      my $caption = $floats{$tag}->{Caption};
      my $type = $floats{$tag}->{Type};

      $contents = "\\begin{$type}"
                . "\\floatconts{$tag}{\\caption{$caption}}{$contents}"
                . "\\end{$type}";
   }

   $contents
}

sub texmenu{
   my $label = shift;

   my @items = split /\./, $label;

   my $text  = '';
   my $index = '';

   my $currentlabel;

   foreach my $item (@items)
   {
      if ($currentlabel)
      {
         $currentlabel .= ".$item";
         $text .= "\\mto ";
         $index .= "!";
      }
      else
      {
         $currentlabel = $item;
      }

      my $word;

      if ($dict{$currentlabel})
      {
         $word = $dict{$currentlabel};
      }
      else
      {
         warn "Undefined dictionary tag '$currentlabel'\n";
         $word = $item;
      }

      $text .= "\\menu{$word}";

      $word=~s/(["@|!])/"$1/g;
      $index .= "$word\@\\menu{$word}";
   }

   "$text\\index{$index}";
}

sub texentity{
   my $entity = shift;

   if ($entity=~/^#(\\d+)$/)
   {
      $entity = chr($1);

      if ($specialchars{$entity})
      {
         $entity = $specialchars{$entity};
      }
   }
   elsif ($entity=~/^#x(\\d+)$/)
   {
      $entity = chr(hex $1);

      if ($specialchars{$entity})
      {
         $entity = $specialchars{$entity};
      }
   }
   elsif ($entities{$entity})
   {
      $entity = $entities{$entity};
   }
   else
   {
      warn "Don't know how to convert '&$entity;'\n";
   }

   $entity
}

sub htmlurl{
   my $url = shift;
   my $text = $url;

   unless ($url=~/^[a-z]+:\/\//)
   {
      $url = "http://$url";
   }

   "<a href=\"$url\">$text</a>";
}

1;
